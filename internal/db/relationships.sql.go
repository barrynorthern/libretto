// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relationships.sql

package db

import (
	"context"
	"encoding/json"
)

const createRelationship = `-- name: CreateRelationship :one

INSERT INTO relationships (id, version_id, from_entity_id, to_entity_id, relationship_type, properties)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at
`

type CreateRelationshipParams struct {
	ID               string          `json:"id"`
	VersionID        string          `json:"version_id"`
	FromEntityID     string          `json:"from_entity_id"`
	ToEntityID       string          `json:"to_entity_id"`
	RelationshipType string          `json:"relationship_type"`
	Properties       json.RawMessage `json:"properties"`
}

// Relationships CRUD operations
func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (Relationship, error) {
	row := q.db.QueryRowContext(ctx, createRelationship,
		arg.ID,
		arg.VersionID,
		arg.FromEntityID,
		arg.ToEntityID,
		arg.RelationshipType,
		arg.Properties,
	)
	var i Relationship
	err := row.Scan(
		&i.ID,
		&i.VersionID,
		&i.FromEntityID,
		&i.ToEntityID,
		&i.RelationshipType,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRelationship = `-- name: DeleteRelationship :exec
DELETE FROM relationships
WHERE id = ?
`

func (q *Queries) DeleteRelationship(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteRelationship, id)
	return err
}

const deleteRelationshipsByEntity = `-- name: DeleteRelationshipsByEntity :exec
DELETE FROM relationships
WHERE from_entity_id = ? OR to_entity_id = ?
`

type DeleteRelationshipsByEntityParams struct {
	FromEntityID string `json:"from_entity_id"`
	ToEntityID   string `json:"to_entity_id"`
}

func (q *Queries) DeleteRelationshipsByEntity(ctx context.Context, arg DeleteRelationshipsByEntityParams) error {
	_, err := q.db.ExecContext(ctx, deleteRelationshipsByEntity, arg.FromEntityID, arg.ToEntityID)
	return err
}

const getRelationship = `-- name: GetRelationship :one
SELECT id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at FROM relationships
WHERE id = ?
`

func (q *Queries) GetRelationship(ctx context.Context, id string) (Relationship, error) {
	row := q.db.QueryRowContext(ctx, getRelationship, id)
	var i Relationship
	err := row.Scan(
		&i.ID,
		&i.VersionID,
		&i.FromEntityID,
		&i.ToEntityID,
		&i.RelationshipType,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}

const getRelationshipsBetweenEntities = `-- name: GetRelationshipsBetweenEntities :many
SELECT id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at FROM relationships
WHERE from_entity_id = ? AND to_entity_id = ?
`

type GetRelationshipsBetweenEntitiesParams struct {
	FromEntityID string `json:"from_entity_id"`
	ToEntityID   string `json:"to_entity_id"`
}

func (q *Queries) GetRelationshipsBetweenEntities(ctx context.Context, arg GetRelationshipsBetweenEntitiesParams) ([]Relationship, error) {
	rows, err := q.db.QueryContext(ctx, getRelationshipsBetweenEntities, arg.FromEntityID, arg.ToEntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.FromEntityID,
			&i.ToEntityID,
			&i.RelationshipType,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationshipsByEntity = `-- name: ListRelationshipsByEntity :many
SELECT id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at FROM relationships
WHERE (from_entity_id = ? OR to_entity_id = ?)
ORDER BY created_at DESC
`

type ListRelationshipsByEntityParams struct {
	FromEntityID string `json:"from_entity_id"`
	ToEntityID   string `json:"to_entity_id"`
}

func (q *Queries) ListRelationshipsByEntity(ctx context.Context, arg ListRelationshipsByEntityParams) ([]Relationship, error) {
	rows, err := q.db.QueryContext(ctx, listRelationshipsByEntity, arg.FromEntityID, arg.ToEntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.FromEntityID,
			&i.ToEntityID,
			&i.RelationshipType,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationshipsByType = `-- name: ListRelationshipsByType :many
SELECT id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at FROM relationships
WHERE version_id = ? AND relationship_type = ?
ORDER BY created_at DESC
`

type ListRelationshipsByTypeParams struct {
	VersionID        string `json:"version_id"`
	RelationshipType string `json:"relationship_type"`
}

func (q *Queries) ListRelationshipsByType(ctx context.Context, arg ListRelationshipsByTypeParams) ([]Relationship, error) {
	rows, err := q.db.QueryContext(ctx, listRelationshipsByType, arg.VersionID, arg.RelationshipType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.FromEntityID,
			&i.ToEntityID,
			&i.RelationshipType,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationshipsByVersion = `-- name: ListRelationshipsByVersion :many
SELECT id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at FROM relationships
WHERE version_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListRelationshipsByVersion(ctx context.Context, versionID string) ([]Relationship, error) {
	rows, err := q.db.QueryContext(ctx, listRelationshipsByVersion, versionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.VersionID,
			&i.FromEntityID,
			&i.ToEntityID,
			&i.RelationshipType,
			&i.Properties,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRelationship = `-- name: UpdateRelationship :one
UPDATE relationships
SET properties = ?
WHERE id = ?
RETURNING id, version_id, from_entity_id, to_entity_id, relationship_type, properties, created_at
`

type UpdateRelationshipParams struct {
	Properties json.RawMessage `json:"properties"`
	ID         string          `json:"id"`
}

func (q *Queries) UpdateRelationship(ctx context.Context, arg UpdateRelationshipParams) (Relationship, error) {
	row := q.db.QueryRowContext(ctx, updateRelationship, arg.Properties, arg.ID)
	var i Relationship
	err := row.Scan(
		&i.ID,
		&i.VersionID,
		&i.FromEntityID,
		&i.ToEntityID,
		&i.RelationshipType,
		&i.Properties,
		&i.CreatedAt,
	)
	return i, err
}
